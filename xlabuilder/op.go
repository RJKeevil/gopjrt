package xlabuilder

// #cgo LDFLAGS: -lgomlx_xlabuilder
/*
#include <gomlx/xlabuilder/op.h>
#include <gomlx/xlabuilder/xlabuilder.h>
*/
import "C"
import "unsafe"

// Op holds information about an Op that is part of a computation being built with an XlaBuilder.
//
// Each operation (e.g: Add, Mul) will return an Op that represents both the operation itself as well as the output
// of that operation, which can be used as input of another.
//
// While the public fields can be introspected, they shouldn't be changed.
type Op struct {
	op    *C.XlaOp
	index int32 // Op index

	// Type is an OpType enum.
	Type OpType

	// OpInputs are the inputs that are generated by other ops, these are the edges on the computation graph.
	// Other inputs are "static", meaning they are independent of the values during the calculation.
	OpInputs []*Op // Index to other nodes that are used as inputs.

	// TODO: Re-write these into more readable arguments to the various operations.

	Literal *Literal     // If a Literal (constant) is involved in the operation.
	Int     int          // Used for any static integer inputs.
	Shape   shapes.Shape // If a shape is used as a static input.
	Str     string       // Used for any static string argument.
	Ints    []int        // List of integer numbers.
	Float   float32      // For a float parameter.

}

func serializedToC(op *Op) *C.SerializedOp {
	// Allocate and set C.SerializedOps struct using Go memory. It can be discarded when this function exit.
	numInputs := len(op.OpInputs)
	var sOp *C.SerializedOp
	sOp = &C.SerializedOp{
		op_type:    C.int32_t(op.Type),
		num_inputs: C.int32_t(numInputs),
		integer:    C.int64_t(op.Int),
		float_v:    C.float(op.Float),
	}
	if numInputs > 0 {
		// Create the `inputs` array.
		sOp.inputs = cMallocArrayAndSet[C.XlaOpPtr](numInputs, func(ii int) C.XlaOpPtr {
			return (C.XlaOpPtr)(unsafe.Pointer(op.OpInputs[ii]))
		})
	}
	if op.Shape.Ok() {
		sOp.shape = cShapeFromShape(op.Shape)
	}
	if op.Str != "" {
		sOp.string = C.CString(op.Str)
	}
	if !op.Literal.IsNil() {
		sOp.literal = op.Literal.cLiteralPtr
	}
	if len(op.Ints) > 0 {
		sOp.integer_array_size = C.int32_t(len(op.Ints))
		sOp.integer_array = cMallocArrayAndSet[C.int64_t](len(op.Ints), func(ii int) C.int64_t { return C.int64_t(op.Ints[ii]) })
	}
	return sOp
}

// freeCSerializedOp frees the C allocated memory within cNode. Note that cNode itself is assumed to be
// allocated in Go space, hence it is (and should be) automatically garbage collected.
func freeCSerializedOp(cNode *C.SerializedOp) {
	if cNode.inputs != nil {
		C.free(unsafe.Pointer(cNode.inputs))
		cNode.inputs = nil
		cNode.num_inputs = 0
	}
	if cNode.shape != nil {
		C.DeleteShape(cNode.shape)
		cNode.shape = nil
	}
	if cNode.new_shape != nil {
		C.DeleteShape(cNode.new_shape)
		cNode.new_shape = nil
	}
	if cNode.string != nil {
		C.free(unsafe.Pointer(cNode.string))
		cNode.string = nil
	}
	if cNode.integer_array != nil {
		C.free(unsafe.Pointer(cNode.integer_array))
		cNode.integer_array = nil
		cNode.integer_array_size = 0
	}
}
