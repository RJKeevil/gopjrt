package xlabuilder

// #cgo LDFLAGS: -lgomlx_xlabuilder
/*
#include <gomlx/xlabuilder/op.h>
#include <gomlx/xlabuilder/xlabuilder.h>
*/
import "C"
import (
	"runtime"
	"unsafe"
)

// Op holds information about an Op that is part of a computation being built with an XlaBuilder.
//
// Each operation (e.g: Add, Mul) will return an Op that represents both the operation itself and the output
// of that operation, which can be used as input of another.
//
// While the public fields can be introspected, they shouldn't be changed.
type Op struct {
	builder *XlaBuilder
	cOp     *C.XlaOp // Pointer to a reference to the underlying C++ object. This should be deleted once Op is garbage collected.

	// Type is an OpType enum.
	Type OpType

	// OpInputs are the inputs that are generated by other ops, these are the edges on the computation graph.
	// Other inputs are "static", meaning they are independent of the values during the calculation.
	OpInputs []*Op // Index to other nodes that are used as inputs.

	// Shape of the result of this Op.
	Shape Shape

	// TODO: Re-write these into more readable arguments to the various operations.

	Literal  *Literal // If a Literal (constant) is involved in the operation.
	Int      int      // Used for any static integer inputs.
	Str      string   // Used for any static string argument.
	Ints     []int    // List of integer numbers.
	Float    float32  // For a float parameter.
	ShapeArg Shape    // For Ops that require a shape parameter.
}

// newOp creates the Op of the given type with the given Op inputs and sets the correct finalizer.
//
// After this Op is created, other static arguments (if any) need to be set, and finally
// it needs to be added to the computation with XlaBuilder.addOp.
func newOp(opType OpType, opInputs ...*Op) *Op {
	op := &Op{
		Type:     opType,
		OpInputs: opInputs,
	}
	runtime.SetFinalizer(op, op.finalize)
	return op
}

// finalize by freeing the underlying C++ resources.
func (op *Op) finalize() {
	if op.cOp == nil {
		return
	}
	C.XlaOpFree(op.cOp)
	op.cOp = nil
}

// serializeToC convert an Op not yet added to XlaBuilder to a C.SerializedOp that can be used by the C-wrapper library.
func serializeToC(op *Op) *C.SerializedOp {
	// Allocate and set C.SerializedOps struct using Go memory. It can be discarded when this function exit.
	numInputs := len(op.OpInputs)
	var sOp *C.SerializedOp
	sOp = &C.SerializedOp{
		op_type:    C.int32_t(op.Type),
		num_inputs: C.int32_t(numInputs),
		integer:    C.int64_t(op.Int),
		float_v:    C.float(op.Float),
	}
	if numInputs > 0 {
		// Create the `inputs` array.
		sOp.inputs = cMallocArrayAndSet[C.XlaOpPtr](numInputs, func(ii int) C.XlaOpPtr {
			return (C.XlaOpPtr)(unsafe.Pointer(op.OpInputs[ii]))
		})
	}
	sOp.shape = cShapeFromShape(op.ShapeArg)
	if op.Str != "" {
		sOp.string = C.CString(op.Str)
	}
	if !op.Literal.IsNil() {
		sOp.literal = op.Literal.cLiteralPtr
	}
	if len(op.Ints) > 0 {
		sOp.integer_array_size = C.int32_t(len(op.Ints))
		sOp.integer_array = cMallocArrayAndSet[C.int64_t](len(op.Ints), func(ii int) C.int64_t { return C.int64_t(op.Ints[ii]) })
	}
	return sOp
}

// freeCSerializedOp frees the C allocated memory within cNode. Note that cNode itself is assumed to be
// allocated in Go space, hence it is (and should be) automatically garbage collected.
func freeCSerializedOp(cOp *C.SerializedOp) {
	if cOp.inputs != nil {
		C.free(unsafe.Pointer(cOp.inputs))
		cOp.inputs = nil
		cOp.num_inputs = 0
	}
	if cOp.shape != nil {
		C.DeleteShape(cOp.shape)
		cOp.shape = nil
	}
	if cOp.new_shape != nil {
		C.DeleteShape(cOp.new_shape)
		cOp.new_shape = nil
	}
	if cOp.string != nil {
		C.free(unsafe.Pointer(cOp.string))
		cOp.string = nil
	}
	if cOp.integer_array != nil {
		C.free(unsafe.Pointer(cOp.integer_array))
		cOp.integer_array = nil
		cOp.integer_array_size = 0
	}
}
