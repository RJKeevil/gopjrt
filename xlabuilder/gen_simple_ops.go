package xlabuilder

/***** File generated by ./cmd/xlabuilder_codegen, based on op_types.txt. Don't edit it directly. *****/

func Abs(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(AbsOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Neg(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(NegOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Exp(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(ExpOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Expm1(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(Expm1Op, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Floor(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(FloorOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Ceil(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(CeilOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Round(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(RoundOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Log(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(LogOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Log1p(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(Log1pOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func LogicalNot(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(LogicalNotOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Logistic(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(LogisticOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Sign(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(SignOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Clz(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(ClzOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Cos(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(CosOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Sin(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(SinOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Tanh(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(TanhOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Sqrt(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(SqrtOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Rsqrt(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(RsqrtOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Imag(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(ImagOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Real(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(RealOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Conj(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp(ConjOp, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Add(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(AddOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Mul(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(MulOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Sub(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(SubOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Div(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(DivOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Rem(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(RemOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func And(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(AndOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Or(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(OrOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Xor(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(XorOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Dot(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(DotOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Min(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(MinOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Max(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(MaxOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Pow(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(PowOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Complex(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(ComplexOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func Equal(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(EqualOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func NotEqual(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(NotEqualOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func GreaterOrEqual(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(GreaterOrEqualOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func GreaterThan(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(GreaterThanOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func LessOrEqual(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(LessOrEqualOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func LessThan(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(LessThanOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func EqualTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(EqualTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func NotEqualTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(NotEqualTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func GreaterOrEqualTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(GreaterOrEqualTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func GreaterThanTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(GreaterThanTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func LessOrEqualTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(LessOrEqualTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}

func LessThanTotalOrder(x0, x1 *Op) (*Op, error) {
	builder := x0.builder
	y := newOp(LessThanTotalOrderOp, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}
