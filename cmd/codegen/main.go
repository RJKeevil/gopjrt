// codegen parses the pjrt_c_api.h and generates boilerplate code for creating the various C structures.
package main

import (
	"bytes"
	"io"
	"os"
	"regexp"
	"slices"
	"text/template"

	"github.com/janpfeifer/must"
)

const (
	NewStructFileName = "gen_new_struct.c"
)

type cStructInfo struct {
	Name, Comments string
	HasStructSize  bool
}

var (
	// reStructs separates all structs using the PJRT_DEFINE_STRUCT_TRAITS macro.
	// Exceptionally, it doesn't capture PJRT_Api, because it is defined differently. But we don't need to create
	// that structure.
	reStructs = regexp.MustCompile(
		`(?m)(((^//.*$\n)*)` + // Match preceding comments.
			`^struct (\w+) \{$\n` + // Start of the struct.
			`(^.*$\n)*?^};$\n` +
			`^PJRT_DEFINE_STRUCT_TRAITS\((\w+),\s+(\w+)\);$\n)`) // End of the struct.

	newStructTemplate = template.Must(template.New("gen_new_struct.c").Parse(`
/***** File generated by ./cmd/codegen, don't edit it directly. *****/

#include <stdlib.h>
#include "pjrt_c_api.h"
#include "common.h"
{{range .}}
// new_{{.Name}} allocates a C.{{.Name}} structure, sets its .struct_size, and returns it.
{{.Comments}}{{.Name}}* new_{{.Name}}() {
	{{.Name}}* p = malloc(sizeof({{.Name}}));{{if .HasStructSize}}
	p->struct_size = {{.Name}}_STRUCT_SIZE;{{end}}
	return p;
}
{{end}}
`))
)

func generateNewStructC(contents string) error {
	var allInfo []cStructInfo
	for _, cStructMatches := range reStructs.FindAllStringSubmatch(contents, -1) {
		info := cStructInfo{
			Name:     cStructMatches[4],
			Comments: cStructMatches[2],
		}
		info.HasStructSize = slices.Index([]string{"PJRT_SendCallbackInfo", "PJRT_RecvCallbackInfo"}, info.Name) == -1
		allInfo = append(allInfo, info)
	}

	f := must.M1(os.Create(NewStructFileName))
	return newStructTemplate.Execute(f, allInfo)
}

func main() {
	// Read pjrt_c_api.h
	f := must.M1(os.OpenFile("pjrt_c_api.h", os.O_RDONLY, os.ModePerm))
	var b bytes.Buffer
	_ = must.M1(io.Copy(&b, f))
	must.M(f.Close())
	contents := b.String()

	// Create various Go generate files.
	must.M(generateNewStructC(contents))
}
