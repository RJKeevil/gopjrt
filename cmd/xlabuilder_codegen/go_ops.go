package main

import (
	"fmt"
	"github.com/janpfeifer/must"
	"os"
	"os/exec"
	"text/template"
)

const simpleGoOpsFileName = "gen_simple_ops.go"

var (
	simpleGoOpsTemplate = template.Must(template.New(simpleGoOpsFileName).Parse(`
package xlabuilder

import (
	"github.com/pkg/errors"
)

/***** File generated by ./cmd/xlabuilder_codegen, based on op_types.txt. Don't edit it directly. *****/
{{range .}}{{if eq .Type "one"}}
// {{.Name}} returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x.
func {{.Name}}(x *Op) (*Op, error) {
	builder := x.builder
	y := newOp({{.Name}}Op, x)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}
{{end}}{{if or (eq .Type "two") (eq .Type "two_cmp")}}
// {{.Name}} returns the Op that represents the output of the corresponding operation.
// The op is created on the same XlaBuilder as used for x0 and x1.
func {{.Name}}(x0, x1 *Op) (*Op, error) {
	if x0.builder != x1.builder {
		return nil, errors.New("arguments of {{.Name}}(x0, x1) come from different XlaBuilder objects (or nil)")
	}
	builder := x0.builder
	y := newOp({{.Name}}Op, x0, x1)
	err := builder.addOp(y)
	if err != nil {
		return nil, err
	}
	return y, nil
}
{{end}}{{end}}`))
)

// GenerateSimpleGoOps will generate the code for the simple to implement Go ops. Currently type of ops supported
// (see op_types.txt):
//
// - one (one arg)
// - two (two arg)
// - two_cmp (two arg comparison ops)
func GenerateSimpleGoOps(opsInfo []OpInfo) {
	fileName := simpleGoOpsFileName
	f := must.M1(os.Create(fileName))
	must.M(simpleGoOpsTemplate.Execute(f, opsInfo))
	must.M(exec.Command("gofmt", "-w", fileName).Run())
	fmt.Printf("Generated %q based on %q\n", fileName, OpTypesFileName)
}
