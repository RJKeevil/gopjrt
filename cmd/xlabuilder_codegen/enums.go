package main

import (
	"fmt"
	"github.com/janpfeifer/must"
	"os"
	"os/exec"
	"text/template"
)

const (
	enumGoFileName = "gen_node_types.go"
	enumCFileName  = "../c/gomlx/xlabuilder/gen_node_types.h"
)

var (
	enumGoTemplate = template.Must(template.New(enumGoFileName).Parse(`
package xlabuilder

/***** File generated by ./cmd/xlabuilder_codegen, based on node_types.txt. Don't edit it directly. *****/

// NodeType enumerates the various types of Nodes supported by XLA.
// A node represent a basic computation operation (XlaOp).
type NodeType int32

const (
{{range .}}	{{.}}
{{end}})
`))

	enumCTemplate = template.Must(template.New(enumCFileName).Parse(`
/***** File generated by ./cmd/xlabuilder_codegen, based on xlabuilder/node_types.txt. Don't edit it directly. *****/

#ifndef _GOMLX_XLABUILDER_GEN_NODE_TYPES_H
#define _GOMLX_XLABUILDER_GEN_NODE_TYPES_H

#ifdef __cplusplus
extern "C" {
#endif

enum NodeType {
{{range .}}  {{.}},
{{end}}};

#ifdef __cplusplus
}
#endif

#endif 
`))
)

func generateNodeEnums(nodeTypeNames []string) {
	declarations := make([]string, len(nodeTypeNames))
	for ii, name := range nodeTypeNames {
		if ii == 0 {
			declarations[ii] = fmt.Sprintf("%s NodeType = iota", name)
		} else {
			declarations[ii] = name
		}
	}

	// Go Enums
	f := must.M1(os.Create(enumGoFileName))
	must.M(enumGoTemplate.Execute(f, declarations))
	must.M(exec.Command("gofmt", "-w", enumGoFileName).Run())
	fmt.Printf("Generated %q based on note_types.txt\n", enumGoFileName)
	// Generate enum names with Go stringer.
	must.M(exec.Command("stringer", "-type=NodeType", enumGoFileName).Run())

	// C Enums
	f = must.M1(os.Create(enumCFileName))
	must.M(enumCTemplate.Execute(f, nodeTypeNames))
	fmt.Printf("Generated %q based on note_types.txt\n", enumCFileName)

}
